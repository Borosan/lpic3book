# 333.1 Discretionary Access Control

#### _Topic 333: Access Control_

**Weight:** 3

**Description:** Candidates should understand discretionary access control (DAC) and know how to implement it using access control lists (ACL). Additionally, candidates are required to understand and know how to use extended attributes.



**Key Knowledge Areas:**

* Understand and manage file ownership and permissions, including SetUID and SetGID bits
* Understand and manage access control lists
* Understand and manage extended attributes and attribute classes

**Partial list of the used files, terms and utilities:**

* getfacl
* setfacl
* getfattr
* setfattr

## basic System Permissions (DAC review)



### chmod

The command you use to change the  permissions on files is called chmod , which stands for “change mode". There  are to ways to tell this command what you want to do:

* using short codes
* using ocatl codes

**1- using short codes:**  That is easier way.&#x20;

<figure><img src=".gitbook/assets/permis-chmodshortcodes.jpg" alt=""><figcaption></figcaption></figure>

```
chmod [reference][operator][mode] file... 
```



reference can be

* &#x20;u as user  (file's owner)
* g as group (users who are members of the file's grou)
* o as others (users who are not the file's owner / members of the file's group)
* a as all (All three of the above, same as ugo)

Operator can be

* \+  Adds the specified modes to the specified classes
* &#x20;\- Removes the specified modes from the specified classes
* \= The modes specified are to be made the exact modes for the specified classes

obviously modes might be

* r  :Permission to read the file
* w :Permission to write (or delete) the file.
* x : Permission to execute the file, or, in the case of a directory, search it.

> Note1: If we want to set different permissions for user, group, or other, we can separate different expressions by commas —for example, `ug=rwx,o=rx`
>
> Note2: using a as ugo with = operator to set exact mode easier

**2- using ocatl codes :** So far we have used symbols (ugoa and rxw) to specify permissions. we can also set permissions using octal numbers instead of symbols.

<figure><img src=".gitbook/assets/permis-chmodoctalcodes.jpg" alt=""><figcaption></figcaption></figure>

For using octal codes with chmod we have to create an octal string, and that's is nothing more than a simple sum of numbers:

| Symbolic | Note  | Octal |
| -------- | ----- | ----- |
| rwx      | 4+2+1 | `7`   |
| rw-      | 4+2   | 6     |
| r-x      | 4+1   | 5     |
| r--      | 4     | 4     |
| -wx      | 2+1   | 3     |
| -w-      | 2     | 2     |
| --x      | 1     | 1     |
| ---      | 0     | 0     |

> Note: To change permissions  recursively on directories and files use `-R` option

### suid , guid

The Linux permissions model has two special access modes called suid (set user id) and sgid (set group id). When an executable program has the suid access modes set, it will run as if it had been started by the file’s owner, rather than by the user who really started it. Similarly, with the sgid access modes set, the program will run as if the initiating user belonged to the file’s group rather than to his own group.

> #### Directories and sgid <a href="#directories-and-sgid" id="directories-and-sgid"></a>
>
> When a directory has the sgid mode enabled, any files or directories created in it will inherit the group ID of the directory. This is particularly useful for directory trees that are used by a group of people working on the same project.

### sticky bit

We have just seen how anyone with write permission to a directory can delete files in it. This might be acceptable for a group project, but is not desirable for globally shared file space such as the /tmp directory. Fortunately, there is a solution.  That  is called the _sticky_ bit.

If set stickybit for a directory, it permits only the owning user or the superuser (root) to delete or unlink a file.&#x20;

| Access mode | on file                                 | on directory                                 |
| ----------- | --------------------------------------- | -------------------------------------------- |
| SUID        | executes with permissions of file owner | nothing                                      |
| GUID        | executes with the permissions of group  | new files have group membership of directory |
| Sticky Bit  | nothing                                 | only owner can delete files                  |

#### How suid, guid and stickybit are implemented?

As there is no more room for setting Access modes, execution character is used. "s" letter is used for both suid and guid but "t" letter is for stickybit. Again we use `+/-` for adding and removing permissions.

<figure><img src=".gitbook/assets/permis-accessmodes.jpg" alt=""><figcaption></figcaption></figure>

> As you have probably noticed, if the file or directory is already executable  **s** and **t** would be displayed  after setting access modes.&#x20;
>
> But if the file or directory hasn't been executable before setting access mode, **S** and **T** would be appear.

#### Setting Access Modes via octal codes:

We can also use octal codes to set suid, guid and stickybit:

| Access Mode | Octal |   |
| ----------- | ----- | - |
| SUID        | 4000  |   |
| GUID        | 2000  |   |
| Sticky Bit  | 1000  |   |



Extended Attributes



Using ACLs



.

.

.

resources:

.
