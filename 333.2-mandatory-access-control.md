# 333.2 Mandatory Access Control

**Weight:** 5

**Description:** Candidates should be familiar with mandatory access control (MAC) systems for Linux. Specifically, candidates should have a thorough knowledge of SELinux. Also, candidates should be aware of other mandatory access control systems for Linux. This includes major features of these systems but not configuration and use.



**Key Knowledge Areas:**

* Understand the concepts of type enforcement, role based access control, mandatory access control and discretionary access control
* Configure, manage and use SELinux
* Awareness of AppArmor and Smack

**Partial list of the used files, terms and utilities:**

* getenforce
* setenforce
* selinuxenabled
* getsebool
* setsebool
* togglesebool
* fixfiles
* restorecon
* setfiles
* newrole
* setcon
* runcon
* chcon
* semanage
* sestatus
* seinfo
* apol
* seaudit
* audit2why
* audit2allow
* /etc/selinux/\*

## Understanding Mandatory Access Control

### **DAC vs. MAC**

The security model used by most mainstream operating systems is based on Discretionary Access Control (DAC), which enforces security by ownership. If a user owns a file, he is allowed to set the read, write, and execute permissions for that file. In this model, users control the data at their discretion. The owner of the system does not have total control over the system; the users do.

However, the biggest concern with the Linux model is the danger presented by the root account. This super-user has the power to control all files and processes. If the root account, or a process that runs with its privileges, is compromised, an attacker can take control of the system and its data.

A more secure approach would limit or even eliminate the need for a root account, and shift the power from the user accounts to the owner of the system. This is MAC’s approach.

MAC makes the enforcement of security policies mandatory instead of discretionary, as you might imagine from the name Mandatory Access Control. Security policies can be set by the system owner and implemented by a system or security administrator. Once these policies are in place, users cannot override them, even if they have root privileges. With MAC, file and process protection is independent of owners.

{% hint style="info" %}
**The concept**

• Mandatory Access Control (MAC) differs from Discretionary Access Control in that access is based on context and not by ownership.&#x20;

• MAC uses roles and type enforcement (TE) to only allow access to users who are authorized to use resources of a specific type.&#x20;

• MAC is generally implemented by means of a kernel module and through use of extended attributes.
{% endhint %}

famous MAC Systems :

• SELinux&#x20;

• AppArmor&#x20;

• Smack

## SELinux

### Overview <a href="#overview" id="overview"></a>

Security-Enhanced Linux (SELinux) is a security architecture for Linux® systems that allows administrators to have more control over who can access the system. It was originally developed by the United States National Security Agency (NSA) as a series of patches to the Linux kernel using Linux Security Modules (LSM). &#x20;

SELinux was released to the open source community in 2000, and was integrated into the upstream Linux kernel in 2003.

{% hint style="success" %}
SELinux is an implementation of _Mandatory Access Control (MAC)_. Depending on the security policy type, SELinux implements either _Type Enforcement (TE)_, _Roles Based Access Control (RBAC)_ or _Bell-La Padula Model Multi-Level Security (MLS)_.
{% endhint %}

### How does SELinux work? <a href="#how-does-it-work" id="how-does-it-work"></a>

SELinux defines access controls for the applications, processes, and files on a system. It uses security policies, which are a set of rules that tell SELinux what can or can’t be accessed, to enforce the access allowed by a policy.&#x20;

When an application or process, known as a subject, makes a request to access an object, like a file, SELinux checks with an access vector cache (AVC), where permissions are cached for subjects and objects.

If SELinux is unable to make a decision about access based on the cached permissions, it sends the request to the security server. The security server checks for the security context of the app or process and the file. Security context is applied from the SELinux policy database. Permission is then granted or denied.&#x20;

If permission is denied, an "avc: denied" message will be available in /var/log.messages.

### How to configure SELinux&#x20;

There are a number of ways that you can configure SELinux to protect your system. The most common are targeted policy or multi-level security (MLS).

Targeted policy is the default option and covers a range of processes, tasks, and services. MLS can be very complicated and is typically only used by government organizations.&#x20;

You can tell what your system is supposed to be running at by looking at the **/etc/sysconfig/selinux** file. The file will have a section that shows you whether SELinux is in permissive mode, enforcing mode, or disabled, and which policy is supposed to be loaded.

```
[root@rocky8 ~]# cat /etc/sysconfig/selinux

# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of these three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted
```

> When ever you make a change you do need to reboot the system

{% hint style="info" %}
#### Enabling SELinux

If SELinux has been disabled in your environment, you can enable SElinux by editing /etc/selinux/config and setting SELINUX=permissive. Since SELinux was not currently enabled, you don’t want to set it to enforcing right away because the system will likely have things mislabeled that can keep the system from booting. &#x20;

You can force the system to automatically [relabel the filesystem](https://access.redhat.com/solutions/24845) by creating an empty file named .autorelabel in the root directory and then rebooting. If the system has too many errors, you should reboot while in permissive mode in order for the boot to succeed. After everything has been relabeled, set SELinux to enforcing with /etc/selinux/config and reboot, or run setenforce 1.&#x20;

If a sysadmin is less familiar with the command line, there are graphic tools available that can be used to manage SELinux.&#x20;

SELinux provides an additional layer of security for your system that is built into Linux distributions. It should remain on so that it can protect your system if it is ever compromised.
{% endhint %}

#### **Checking SELinux Mode of Operation**

SELinux is enabled by default and works in the “Enforcing” mode, which is its default mode. You can determine this by   opening the SELinux configuration file **or by** running the “sestatus” command.

```
[root@rocky8 ~]# sestatus
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Memory protection checking:     actual (secure)
Max kernel policy version:      33
```

This can also be verified by running getenforce command.

#### getenforce

```
[root@rocky8 ~]# getenforce
Enforcing
```

#### setenforce

The second command to know is how to set an SELinux status. The command for this is setenforce. With this command, you can change the SELinux status from any one of the following:

* disabled: SELinux is disabled
* permissive: SELinux prints warnings instead of enforcing policies
* enforcing: SELinux enforces security policies

```
[root@rocky8 ~]# setenforce 0
[root@rocky8 ~]# getenforce
Permissive
```

{% hint style="danger" %}
keep it mind that this is for the time we arerunning here  and if you reboot the system it would retrieve the values from the /etc/sysconfig/selinux config file, and reenable it on reboot.
{% endhint %}

turn it back on:

```
[root@rocky8 ~]# setenforce 1
[root@rocky8 ~]# getenforce
Enforcing
```

{% hint style="success" %}
**Booleans**

Booleans allow parts of SELinux policy to be changed at runtime, without any knowledge of SELinux policy writing. This allows changes, such as allowing services access to NFS volumes, without reloading or recompiling SELinux policy.
{% endhint %}

#### semanage

For a list of Booleans, an explanation of what each one is, and whether they are on or off, run the `semanage boolean -l` command as the Linux root user.

{% hint style="info" %}
you might need to install policycoreutils-python-utils-2.9-19.el8.noarch for that.
{% endhint %}

&#x20;The following example does not list all Booleans:

```
[root@rocky8 ~]# semanage boolean -l
SELinux boolean                State  Default Description

abrt_anon_write                (off  ,  off)  Allow abrt to anon write
abrt_handle_event              (off  ,  off)  Allow abrt to handle event
abrt_upload_watch_anon_write   (on   ,   on)  Allow abrt to upload watch anon write
antivirus_can_scan_system      (off  ,  off)  Allow antivirus to can scan system
.
.
.
```

The `SELinux boolean` column lists Boolean names. The `Description` column lists whether the Booleans are on or off, and what they do.

#### getsebool

The `getsebool -a` command lists Booleans, whether they are on or off, but does not give a description of each one. The following example does not list all Booleans:

```
[root@rocky8 ~]# getsebool
usage:  getsebool -a or getsebool boolean...
[root@rocky8 ~]#
[root@rocky8 ~]# getsebool -a
abrt_anon_write --> off
abrt_handle_event --> off
abrt_upload_watch_anon_write --> on
antivirus_can_scan_system --> off
antivirus_use_jit --> off
.
.
.
```

Run the `getsebool`` `_`boolean-name`_ command to only list the status of the _boolean-name_ Boolean:

```
[root@rocky8 ~]# getsebool  ftpd_anon_write
ftpd_anon_write --> off
```

> Use a space-separated list to list multiple Booleans

#### setsebool

Run the `setsebool` utility in the `setsebool`` `_`boolean_name`_` ``on/off` form to enable or disable Booleans.The following example demonstrates configuring the `httpd_can_network_connect_db` Boolean:

1.By default, the `httpd_can_network_connect_db` Boolean is off, preventing Apache HTTP Server scripts and modules from connecting to database servers:

```
[root@rocky8 ~]# getsebool httpd_can_network_connect_db
httpd_can_network_connect_db --> off
```

2.To temporarily enable Apache HTTP Server scripts and modules to connect to database servers, run the `setsebool httpd_can_network_connect_db on` command as the Linux root user.

```
[root@rocky8 ~]# setsebool httpd_can_network_connect_db on
```

3.Use the `getsebool httpd_can_network_connect_db` command to verify the Boolean is enabled:

```
[root@rocky8 ~]# getsebool httpd_can_network_connect_db
httpd_can_network_connect_db --> on
```

_This allows Apache HTTP Server scripts and modules to connect to database servers._

_4._This change is not persistent across reboots. To make changes persistent across reboots, run the `setsebool -P`` `_`boolean-name`_` ``on` command as the Linux root user:

```
[root@rocky8 ~]# setsebool -P httpd_can_network_connect_db on
```

> To temporarily revert to the default behavior, as the Linux root user, run the `setsebool httpd_can_network_connect_db off` command. For changes that persist across reboots, run the `setsebool -P httpd_can_network_connect_db off` command.

{% hint style="success" %}
#### SELinux Contexts – Labeling Files

On systems running SELinux, all processes and files are labeled in a way that represents security-relevant information. This information is called the SELinux context. For files, this is viewed using the `ls -Z` command:

```
ls -Z file1
-rw-rw-r--  user1 group1 unconfined_u:object_r:user_home_t:s0 file1
```

In this example, SELinux provides a user (`unconfined_u`), a role (`object_r`), a type (`user_home_t`), and a level (`s0`). This information is used to make access control decisions. On DAC systems, access is controlled based on Linux user and group IDs. SELinux policy rules are checked after DAC rules. SELinux policy rules are not used if DAC rules deny access first.

__

_Note: By default, newly-created files and directories inherit the SELinux type of their parent directories._



SELinux provides multiple commands for managing the file system labeling, such as `chcon`, `semanage fcontext`, `restorecon`, and `matchpathcon`.
{% endhint %}

#### chcon

The `chcon` command changes the SELinux context for files. However, changes made with the `chcon` command are not persistent across file-system relabels, or the execution of the `restorecon` command. SELinux policy controls whether users are able to modify the SELinux context for any given file. When using `chcon`, users provide all or part of the SELinux context to change. An incorrect file type is a common cause of SELinux denying access.

{% hint style="info" %}
#### Quick Reference <a href="#brid-security-enhanced_linux-temporary_changes_chcon-quick_reference" id="brid-security-enhanced_linux-temporary_changes_chcon-quick_reference"></a>

*   Run the `chcon -t`` `_`type`_` ```` `_`file-name`_ command to change the file type, where _type_ is an SELinux type, such as `httpd_sys_content_t`, and _file-name_ is a file or directory name:

    ```
    ~]$ chcon -t httpd_sys_content_t file-name
    ```
*   Run the `chcon -R -t`` `_`type`_` ```` `_`directory-name`_ command to change the type of the directory and its contents, where _type_ is an SELinux type, such as `httpd_sys_content_t`, and _directory-name_ is a directory name:

    ```
    ~]$ chcon -R -t httpd_sys_content_t directory-name
    ```
{% endhint %}

The following example demonstrates changing the type, and no other attributes of the SELinux context. The example in this section works the same for directories, for example, if `file1` was a directory.

1.Change into your home directory.

2.Create a new file and view its SELinux context:

```
[user@rocky8 sandbox]$ touch file1
[user@rocky8 sandbox]$ ls -lZ
total 0
-rw-rw-r--. 1 user user unconfined_u:object_r:user_home_t:s0 0 Sep  8 08:03 file1
```

In this example, the SELinux context for `file1` includes the SELinux `unconfined_u` user, `object_r` role, `user_home_t` type, and the `s0` level.

3.Enter the following command to change the type to `samba_share_t`. The `-t` option only changes the type. Then view the change:

```
[user@rocky8 sandbox]$ chcon -t samba_share_t file1
[user@rocky8 sandbox]$ ls -lZ
total 0
-rw-rw-r--. 1 user user unconfined_u:object_r:samba_share_t:s0 0 Sep  8 08:03 file1
```

#### restorecon

4.Use the following command to restore the SELinux context for the `file1` file. Use the `-v` option to view what changes:

```
user@rocky8 sandbox]$ restorecon -v file1
Relabeled /home/user/sandbox/file1 from unconfined_u:object_r:samba_share_t:s0 to unconfined_u:object_r:user_home_t:s0
[user@rocky8 sandbox]$ ls -lZ
total 0
-rw-rw-r--. 1 user user unconfined_u:object_r:user_home_t:s0 0 Sep  8 08:03 file1
```

In this example, the previous type, `samba_share_t`, is restored to the correct, `user_home_t` type. When using targeted policy (the default SELinux policy in Red Hat Enterprise Linux), the `restorecon` command reads the files in the `/etc/selinux/targeted/contexts/files/` directory, to see which SELinux context files should have.

#### filefix

fixfiles - fix file SELinux security contexts . What this command does is the the same as restorcon command.  for more information read man 8 fixfiles.

{% hint style="success" %}
**role**

Part of SELinux is the Role-Based Access Control (RBAC) security model. The role is an attribute of RBAC. SELinux users are authorized for roles, and roles are authorized for domains. The role serves as an intermediary between domains and SELinux users. The roles that can be entered determine which domains can be entered; ultimately, this controls which object types can be accessed. This helps reduce vulnerability to privilege escalation attacks.
{% endhint %}

#### newrole

Run a new shell in a new context. read `man newrole` for more information.

> this command is used rarely, most admins prefer using existing roles.

#### semanage



All of the `semanage` commands that add or modify the targeted policy configuration store information in `*local` files under the `/etc/selinux/targeted` directory tree. These files all have warnings that they should not be edited directly but are used to preserve customization. When the SELinux and policy packages are updated, these local customization files are left in place and applied to the updated policy.



{% hint style="info" %}
#### SELinux labeling and type enforcement&#x20;

Type enforcement and labeling are the most important concepts for SELinux.

SELinux works as a labeling system, which means that all of the files, processes, and ports in a system have an SELinux label associated with them. Labels are a logical way of grouping things together. The kernel manages the labels during boot.

Labels are in the format user:role:type:level (level is optional). User, role, and level are used in more advanced implementations of SELinux, like with MLS. Label type is the most important for targeted policy.&#x20;

SELinux uses type enforcement to enforce a policy that is defined on the system. Type enforcement is the part of an SELinux policy that defines whether a process running with a certain type can access a file labeled with a certain type.
{% endhint %}

####







MAC Alternatives



.

.

.

resources:

[https://www.linux.com/news/securing-linux-mandatory-access-controls/](https://www.linux.com/news/securing-linux-mandatory-access-controls/)

[https://www.redhat.com/en/topics/linux/what-is-selinux](https://www.redhat.com/en/topics/linux/what-is-selinux)

[https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/5/html/deployment\_guide/rhlcommon-chapter-0001#sec-selinux-types](https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/5/html/deployment\_guide/rhlcommon-chapter-0001#sec-selinux-types)

[https://linuxhint.com/basic-selinux-commands/](https://linuxhint.com/basic-selinux-commands/)

[https://www.techtarget.com/searchdatacenter/tip/SELinux-tutorial-Commands-and-management](https://www.techtarget.com/searchdatacenter/tip/SELinux-tutorial-Commands-and-management)

[https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/6/html/security-enhanced\_linux/sect-security-enhanced\_linux-working\_with\_selinux-booleans](https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/6/html/security-enhanced\_linux/sect-security-enhanced\_linux-working\_with\_selinux-booleans)

[https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/7/html/selinux\_users\_and\_administrators\_guide/sect-security-enhanced\_linux-working\_with\_selinux-selinux\_contexts\_labeling\_files](https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/7/html/selinux\_users\_and\_administrators\_guide/sect-security-enhanced\_linux-working\_with\_selinux-selinux\_contexts\_labeling\_files)

[https://www.systutorials.com/docs/linux/man/8-fixfiles/](https://www.systutorials.com/docs/linux/man/8-fixfiles/)

[https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/5/html/deployment\_guide/sec-selinux-policy-targeted-rolesandusers](https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/5/html/deployment\_guide/sec-selinux-policy-targeted-rolesandusers)

__[https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/6/html/security-enhanced\_linux/chap-security-enhanced\_linux-selinux\_contexts#:\~:text=Security%20(MCS).-,role,between%20domains%20and%20SELinux%20users.](https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/6/html/security-enhanced\_linux/chap-security-enhanced\_linux-selinux\_contexts)

[https://www.redhat.com/sysadmin/semanage-keep-selinux-enforcing](https://www.redhat.com/sysadmin/semanage-keep-selinux-enforcing)

.
