# 334.3 Packet Filtering

**Weight:** 5

**Description:** Candidates should be familiar with the use and configuration of the netfilter Linux packet filter.



**Key Knowledge Areas:**

* Understand common firewall architectures, including DMZ
* Understand and use iptables and ip6tables, including standard modules, tests and targets
* Implement packet filtering for IPv4 and IPv6
* Implement connection tracking and network address translation
* Manage IP sets and use them in netfilter rules
* Awareness of nftables and nft
* Awareness of ebtables
* Awareness of conntrackd

**Partial list of the used files, terms and utilities:**

* iptables
* ip6tables
* iptables-save
* iptables-restore
* ip6tables-save
* ip6tables-restore
* ipset

## Firewall Review

Lets review what we have learned from LPIC-2:

### netfilter

Like any other modern operating system, linux has firewall. First lets see how linux firewalling is organized:

<figure><img src=".gitbook/assets/route-netfilter.jpg" alt=""><figcaption></figcaption></figure>

There is a firewalling functionality which is implemented in linux kernel with netfilter. netfilter is a kernel module and any network traffic which kernel forward to any interface(s), is pass through netfilter. This way netfilter can make decision whether incomming or out going traffic is allowed or not. The major interface to the netfilter module is iptables. iptables has been around for a long time and it let us to do any advanced configuration on linux firewalls.

While being able to do any advanced firewall configuration is count as iptables advantage, the biggest disadvantage of iptables is its complexity. This disadvantage has been caused other solutions have been invented like ufw , firewalld . They both work with iptables behind the sence and make firewall configuration easier for us.

### iptables

iptables works with tables! There are at present three tables:

* **Filter :** The filter table is used for packet filtering.
* **NAT :** The nat table is used for address translation.
* **Mangle :** The mangle table can be used for special-purpose processing of packets.

Within tables there are chains. Chains are used to define what kind of packet follow should be filtered exactly.

<figure><img src=".gitbook/assets/route-iptables.jpg" alt=""><figcaption></figcaption></figure>

* **PREROUTING:** configured to block, redirect or allow the packet to the next chain. Commonly, used to redirect the packet to another address or/and port. (DNAT-Destination NAT).  If destination is local ( this machine) sent to INPUT chain. If bound for another network, sent to the FORWARD chain.
* INPUT: Configured to be blocked, logged or sent to the local system to be handled by the appropriate client, application or service.
* OUTPUT:  packet is sent from the firewall out to the network to its final destination.(Rules usually are not applied at this chain)
* FORWARD : Configured to block, logged or sent to the POSTROUTING chain.
* **POSTROUTING:**  make changes to the packet as it exits the firewall, commonly used to do masquerading.&#x20;

How tables and chain are related so ? All three tree tables (FILTER, NAT, MANGLE) can be present in chains(filter points) but not every chain has all three table represented:

<figure><img src=".gitbook/assets/route-iptables-tchains.jpg" alt=""><figcaption></figcaption></figure>

* **PREROUTING ( **_**NAT**_** ,** MANGLE**)**
* INPUT (**FILTER** , MANGLE )
* FORWARD (**FILTER** , MANGLE )
* OUTPUT (**FILTER** ,  _**NAT**_ , MANGLE)
* **POSTROUTING (**_**NAT**_** ,** MANGLE**)**

How rules are broken down within the firewall system? chains are filtering points that we can create rules, and rules are apllied to the packet passing trough. The rules define what exactly should happen to a packet.

When packets are filterd trough the iptables firewall it will go tough the rules one by one, and the idea is "exit on match". So if a packet matches specific rule , the rule will be applied and nothing else will be applied in that chain any more. So ordering in iptables is very important.

In every rule there us target, The typical target is ACCEPT:

* **ACCEPT** : the package is allowed
* **DROP** : The package is not allowed, the package will be sileintly dropped and the sender of package doesn't know anything.
* **REJECT** :  Do not allow package, the sender of package will get an ICMP warnnig message.
* **LOG :** just LOGs
* **MASQUARATE :** used for NAT.

the target indicated with -j option. we will talk about that.

In every chain there is a policy. The policy define the default behaviour. The default policy is ACCEPT but its isa good practice to have a policy that will drop every thing that doesn't match specific packet in a chain. to set chain default policy

### iptables commands

iptables commands can be pretty long, and sometimes hard to understand so lets default components in iptables commands. to make it easier see this example:

```
iptables -A chain [-i/-o interface] [-s/-d address] -p udp --sport/--dport 80  -j TARGET
```

`-A` appends to the end gollowed by the name of the chain, `[-i/-o interface]` incomming or outgoing interface,`[ -s/-d ]` source address or destination address,`-p` defines the protocol like tcp or udp, `[--sport/--dport]`for setting source or destination port number, `-j TARGET` which define what will happend to the packet that match this rule.

iptables command options outside of adding rules to chain:

| Option                            | Description                                                                                           |   |
| --------------------------------- | ----------------------------------------------------------------------------------------------------- | - |
| -L \<chain-name> -t \<table-name> | Lists all of the rules in the  specified chain and table. If not chain or table specified, shows all. |   |
| -D                                | Deletes a rule in a particular chain by number                                                        |   |
| -X                                | Deletes chain                                                                                         |   |
| -F (or --flush)                   | flushes all (or indicated chain) of rules                                                             |   |
| -P                                | change the default policy for the chain(can be set to DROP or ACCEPT)                                 |   |
| -v                                | typically used with -F(or --flush) to provide additional output                                       |   |
| -n                                | Display IP address and port in numeric format                                                         |   |

list current rules:

```
[root@rocky8 ~]# iptables -nvL
Chain INPUT (policy ACCEPT 398K packets, 525M bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 184K packets, 15M bytes)
 pkts bytes target     prot opt in     out     source               destination
```

{% hint style="info" %}
In every chain there is a policy. The policy define the default behaviour. The default policy is ACCEPT but its isa good practice to have a policy that will drop every thing that doesn't match specific packet in a chain.

```
iptables -P INPUT DROP

```

**note:** linux uses loopback adapter for internal communication.
{% endhint %}

#### adding rules

```
iptables [-t table] {-A|-C|-D} chain rule-specification
```

| Option | Description                                                                       |   |
| ------ | --------------------------------------------------------------------------------- | - |
| -A     | Append one or more rules to the end of the selected chain.                        |   |
| -C     | Check whether a rule matching the specification does exist in the selected chain. |   |

examples:

```
### Block TCP traffic from Specific IP Address:
iptables -A INPUT -p tcp -s xxx.xxx.xxx.xxx -j DROP

### Allow All tcp xxx incomming port:
iptables -A INPUT -p tcp --dport xxx -j ACCEPT

### Allow Specific Network Range on Particular Port:
iptables -A OUTPUT -p tcp -d 192.168.100.0/24 --dport 22 -j ACCEPT
```

#### Inserting rules

```
iptables [-t table] -I chain [rulenum] rule-specification
```

You can use line numbers to delete or insert new rules into the firewall. example:

```
### To insert rule between 1 and 2, enter:
iptables -I INPUT 2 -s 202.54.1.2 -j DROP
```

#### deleting rules

```
iptables [-t table] -D chain rulenum
```

There are two ways for deleting a rule:

* using -D option with full length of rule&#x20;

```
iptables -D OUTPUT -p tcp --sport 22 -j ACCEPT
```

* or use iptables -L --line-numbers and delete a rule by using its number in the table (to show: `iptables -L --line-numbers`):

```
iptables -D INPUT 2
```

### /etc/sysconfig/iptables

The /etc/sysconfig/iptables config file **stores information used by the kernel to set up packet filtering services at boot time or whenever the service is started**. Do not modify this file by hand unless you are familiar with constructing iptables rules.

#### iptables-save

iptables rules are not persisyent and they are vanished after reboot. rules are stored in /etc/sysconfig/iptables . for saving rules we use iptables-save command:

```
[root@rocky8 ~]# iptables-save > /etc/sysconfig/iptables.$(date +%d-%m-%y)
```

#### iptables-restore

use iptables-restore to restore  from the backup:

```
[root@rocky8 ~]# iptables-restore < /etc/sysconfig/iptables.20-09-22
```

### ip6tables&#x20;

Ip6tables is used to set up, maintain, and inspect the tables of IPv6 packet filter rules where as Iptables is used to set up, maintain, and inspect the tables of IPv4 packet filter rules in the Linux kernel.however the syntax for both almost same.

## Advanced Firewall Concepts

### ipsets

IP sets are stored collections of IP addresses, network ranges, MAC addresses, port numbers, and network interface names. The iptables tool can leverage IP sets for more efficient rule matching. For example, let’s say you want to drop traffic that originates from one of several IP address ranges that you know to be malicious. Instead of configuring rules for each range in iptables directly, you can create an IP set and then reference that set in an iptables rule. This makes your rule sets dynamic and therefore easier to configure; whenever you need to add or swap out network identifiers that are handled by the firewall, you simply change the IP set.

#### ipset

The **ipset** command enables you to create and modify IP sets. First you need to set a name, storage method, and data type for your set, such as:

```
# ipset create range_set hash:net
```

In this case, range\_set is the name, hash is the storage method, and net is the data type. Then, you can add the ranges to the set:

```
# ipset add range_set 192.168.100.0/24
# ipset add range_set 192.168.200.0/24
```

Then, you use iptables to configure a rule to drop traffic whose source matches the ranges in this set:

```
# iptables -I INPUT -m set --match-set range_set src -j DROP
```

Or, alternatively, to drop traffic whose destination matches the set:

```
iptables -I OUTPUT -m set --match-set range_set dst -j DROP
```

now that you know concept, lets see other ipset commands from its man page:

```
### Create a set identified with setname and specified type.       
ipset create SETNAME TYPENAME [ CREATE-OPTIONS ]

###Add a given entry to the set. 
ipset add SETNAME ADD-ENTRY [ ADD-OPTIONS ]

### Delete an entry from a set. 
ipset del SETNAME DEL-ENTRY [ DEL-OPTIONS ]

### Test wether an entry is in a set or not. 
### Exit status number is zero if the tested entry is in the set and nonzero if it is missing from the set.
ipset test SETNAME TEST-ENTRY [ TEST-OPTIONS ]

### Destroy the specified set or all the sets if none is given.
ipset destroy [ SETNAME ]

### List the header data and the entries for the specified set, or for all sets if none is given. 
ipset list [ SETNAME ]

### Flush all entries from the specified set or flush all sets if none is given.
ipset flush [ SETNAME ]

###Rename a set. Set identified by SETNAME-TO must not exist.
ipset rename SETNAME-FROM SETNAME-TO

### exchange the name of two sets. 
### The referred sets must exist and identical type of sets can be swapped only.
ipset swap SETNAME-FROM SETNAME-TO
```

example:

```
[root@rocky8 ~]# ipset create webserver hash:ip,port

[root@rocky8 ~]# ipset add webserver 10.0.0.1,80

[root@rocky8 ~]# ipset list  webserver
Name: webserver
Type: hash:ip,port
Revision: 5
Header: family inet hashsize 1024 maxelem 65536
Size in memory: 184
References: 0
Number of entries: 1
Members:
10.0.0.1,tcp:80
```

#### Making ipset persistent

The ipset you have created is stored in memory and will be gone after reboot. To make the ipset persistent you have to do the followings:

```
# ipset save > /etc/ipset.conf
```

and to restore:

```
# ipset restore < /etc/ipset.conf
```

{% hint style="info" %}
ipset interactive mode

ipset also have an interactive modes, try **`ipset -`** command. The interactive mode can be finished by entering the pseudo-command quit.
{% endhint %}



Nftables

.

.

.

resource:

[http://underpop.online.fr/l/linux/en/centos/s2-sysconfig-iptables.htm#:\~:text=The%20%2Fetc%2Fsysconfig%2Fiptables,familiar%20with%20constructing%20iptables%20rules.](http://underpop.online.fr/l/linux/en/centos/s2-sysconfig-iptables.htm)

[https://blog.knoldus.com/ip6tables-firewall/#:\~:text=configurable%20table%20rules.-,iptable%20vs%20ip6tables,syntax%20for%20both%20almost%20same.](https://blog.knoldus.com/ip6tables-firewall/)

[https://www.thegeekdiary.com/how-to-use-ipset-command-in-linux/](https://www.thegeekdiary.com/how-to-use-ipset-command-in-linux/)

[https://linux.die.net/man/8/ipset](https://linux.die.net/man/8/ipset)

.
